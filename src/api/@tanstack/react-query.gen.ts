// This file is auto-generated by @hey-api/openapi-ts

import { type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { acknowledgeAlert, cancelExecution, createAlert, createWorkflow, deleteWorkflow, executeWorkflow, getAlert, getExecution, getWorkflow, healthCheck, listAlerts, listAuditLogs, listAuditLogsByResource, listAuditLogsByUser, listExecutions, listWorkflowExecutions, listWorkflows, livenessProbe, type Options, readinessProbe, resolveAlert, updateWorkflow } from '../sdk.gen';
import type { AcknowledgeAlertData, AcknowledgeAlertError, AcknowledgeAlertResponse, CancelExecutionData, CancelExecutionError, CancelExecutionResponse, CreateAlertData, CreateAlertError, CreateAlertResponse, CreateWorkflowData, CreateWorkflowError, CreateWorkflowResponse, DeleteWorkflowData, DeleteWorkflowError, DeleteWorkflowResponse, ExecuteWorkflowData, ExecuteWorkflowError, ExecuteWorkflowResponse, GetAlertData, GetAlertError, GetAlertResponse, GetExecutionData, GetExecutionError, GetExecutionResponse, GetWorkflowData, GetWorkflowError, GetWorkflowResponse, HealthCheckData, HealthCheckError, HealthCheckResponse, ListAlertsData, ListAlertsError, ListAlertsResponse, ListAuditLogsByResourceData, ListAuditLogsByResourceError, ListAuditLogsByResourceResponse, ListAuditLogsByUserData, ListAuditLogsByUserError, ListAuditLogsByUserResponse, ListAuditLogsData, ListAuditLogsError, ListAuditLogsResponse, ListExecutionsData, ListExecutionsError, ListExecutionsResponse, ListWorkflowExecutionsData, ListWorkflowExecutionsError, ListWorkflowExecutionsResponse, ListWorkflowsData, ListWorkflowsError, ListWorkflowsResponse, LivenessProbeData, LivenessProbeError, LivenessProbeResponse, ReadinessProbeData, ReadinessProbeError, ReadinessProbeResponse, ResolveAlertData, ResolveAlertError, ResolveAlertResponse, UpdateWorkflowData, UpdateWorkflowError, UpdateWorkflowResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const healthCheckQueryKey = (options?: Options<HealthCheckData>) => createQueryKey('healthCheck', options);

/**
 * Health check
 *
 * Returns the overall health status of the service
 */
export const healthCheckOptions = (options?: Options<HealthCheckData>) => queryOptions<HealthCheckResponse, HealthCheckError, HealthCheckResponse, ReturnType<typeof healthCheckQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await healthCheck({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: healthCheckQueryKey(options)
});

export const livenessProbeQueryKey = (options?: Options<LivenessProbeData>) => createQueryKey('livenessProbe', options);

/**
 * Liveness probe
 *
 * Kubernetes liveness probe endpoint
 */
export const livenessProbeOptions = (options?: Options<LivenessProbeData>) => queryOptions<LivenessProbeResponse, LivenessProbeError, LivenessProbeResponse, ReturnType<typeof livenessProbeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await livenessProbe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: livenessProbeQueryKey(options)
});

export const readinessProbeQueryKey = (options?: Options<ReadinessProbeData>) => createQueryKey('readinessProbe', options);

/**
 * Readiness probe
 *
 * Kubernetes readiness probe endpoint
 */
export const readinessProbeOptions = (options?: Options<ReadinessProbeData>) => queryOptions<ReadinessProbeResponse, ReadinessProbeError, ReadinessProbeResponse, ReturnType<typeof readinessProbeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await readinessProbe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: readinessProbeQueryKey(options)
});

export const listWorkflowsQueryKey = (options?: Options<ListWorkflowsData>) => createQueryKey('listWorkflows', options);

/**
 * List workflows
 *
 * Returns a paginated list of workflows for the current tenant
 */
export const listWorkflowsOptions = (options?: Options<ListWorkflowsData>) => queryOptions<ListWorkflowsResponse, ListWorkflowsError, ListWorkflowsResponse, ReturnType<typeof listWorkflowsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listWorkflows({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listWorkflowsQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const listWorkflowsInfiniteQueryKey = (options?: Options<ListWorkflowsData>): QueryKey<Options<ListWorkflowsData>> => createQueryKey('listWorkflows', options, true);

/**
 * List workflows
 *
 * Returns a paginated list of workflows for the current tenant
 */
export const listWorkflowsInfiniteOptions = (options?: Options<ListWorkflowsData>) => infiniteQueryOptions<ListWorkflowsResponse, ListWorkflowsError, InfiniteData<ListWorkflowsResponse>, QueryKey<Options<ListWorkflowsData>>, number | Pick<QueryKey<Options<ListWorkflowsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListWorkflowsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listWorkflows({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listWorkflowsInfiniteQueryKey(options)
});

/**
 * Create workflow
 *
 * Creates a new workflow definition
 */
export const createWorkflowMutation = (options?: Partial<Options<CreateWorkflowData>>): UseMutationOptions<CreateWorkflowResponse, CreateWorkflowError, Options<CreateWorkflowData>> => {
    const mutationOptions: UseMutationOptions<CreateWorkflowResponse, CreateWorkflowError, Options<CreateWorkflowData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createWorkflow({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete workflow
 *
 * Deletes a workflow by ID
 */
export const deleteWorkflowMutation = (options?: Partial<Options<DeleteWorkflowData>>): UseMutationOptions<DeleteWorkflowResponse, DeleteWorkflowError, Options<DeleteWorkflowData>> => {
    const mutationOptions: UseMutationOptions<DeleteWorkflowResponse, DeleteWorkflowError, Options<DeleteWorkflowData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteWorkflow({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkflowQueryKey = (options: Options<GetWorkflowData>) => createQueryKey('getWorkflow', options);

/**
 * Get workflow
 *
 * Returns a single workflow by ID
 */
export const getWorkflowOptions = (options: Options<GetWorkflowData>) => queryOptions<GetWorkflowResponse, GetWorkflowError, GetWorkflowResponse, ReturnType<typeof getWorkflowQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getWorkflow({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getWorkflowQueryKey(options)
});

/**
 * Update workflow
 *
 * Updates an existing workflow. Version is auto-incremented.
 */
export const updateWorkflowMutation = (options?: Partial<Options<UpdateWorkflowData>>): UseMutationOptions<UpdateWorkflowResponse, UpdateWorkflowError, Options<UpdateWorkflowData>> => {
    const mutationOptions: UseMutationOptions<UpdateWorkflowResponse, UpdateWorkflowError, Options<UpdateWorkflowData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateWorkflow({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Execute workflow
 *
 * Triggers a new execution of the workflow
 */
export const executeWorkflowMutation = (options?: Partial<Options<ExecuteWorkflowData>>): UseMutationOptions<ExecuteWorkflowResponse, ExecuteWorkflowError, Options<ExecuteWorkflowData>> => {
    const mutationOptions: UseMutationOptions<ExecuteWorkflowResponse, ExecuteWorkflowError, Options<ExecuteWorkflowData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await executeWorkflow({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listWorkflowExecutionsQueryKey = (options: Options<ListWorkflowExecutionsData>) => createQueryKey('listWorkflowExecutions', options);

/**
 * List workflow executions
 *
 * Returns a paginated list of executions for a specific workflow
 */
export const listWorkflowExecutionsOptions = (options: Options<ListWorkflowExecutionsData>) => queryOptions<ListWorkflowExecutionsResponse, ListWorkflowExecutionsError, ListWorkflowExecutionsResponse, ReturnType<typeof listWorkflowExecutionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listWorkflowExecutions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listWorkflowExecutionsQueryKey(options)
});

export const listWorkflowExecutionsInfiniteQueryKey = (options: Options<ListWorkflowExecutionsData>): QueryKey<Options<ListWorkflowExecutionsData>> => createQueryKey('listWorkflowExecutions', options, true);

/**
 * List workflow executions
 *
 * Returns a paginated list of executions for a specific workflow
 */
export const listWorkflowExecutionsInfiniteOptions = (options: Options<ListWorkflowExecutionsData>) => infiniteQueryOptions<ListWorkflowExecutionsResponse, ListWorkflowExecutionsError, InfiniteData<ListWorkflowExecutionsResponse>, QueryKey<Options<ListWorkflowExecutionsData>>, number | Pick<QueryKey<Options<ListWorkflowExecutionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListWorkflowExecutionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listWorkflowExecutions({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listWorkflowExecutionsInfiniteQueryKey(options)
});

export const listExecutionsQueryKey = (options?: Options<ListExecutionsData>) => createQueryKey('listExecutions', options);

/**
 * List executions
 *
 * Returns a paginated list of all executions for the current tenant
 */
export const listExecutionsOptions = (options?: Options<ListExecutionsData>) => queryOptions<ListExecutionsResponse, ListExecutionsError, ListExecutionsResponse, ReturnType<typeof listExecutionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listExecutions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listExecutionsQueryKey(options)
});

export const listExecutionsInfiniteQueryKey = (options?: Options<ListExecutionsData>): QueryKey<Options<ListExecutionsData>> => createQueryKey('listExecutions', options, true);

/**
 * List executions
 *
 * Returns a paginated list of all executions for the current tenant
 */
export const listExecutionsInfiniteOptions = (options?: Options<ListExecutionsData>) => infiniteQueryOptions<ListExecutionsResponse, ListExecutionsError, InfiniteData<ListExecutionsResponse>, QueryKey<Options<ListExecutionsData>>, number | Pick<QueryKey<Options<ListExecutionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListExecutionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listExecutions({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listExecutionsInfiniteQueryKey(options)
});

export const getExecutionQueryKey = (options: Options<GetExecutionData>) => createQueryKey('getExecution', options);

/**
 * Get execution
 *
 * Returns a single execution by ID
 */
export const getExecutionOptions = (options: Options<GetExecutionData>) => queryOptions<GetExecutionResponse, GetExecutionError, GetExecutionResponse, ReturnType<typeof getExecutionQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getExecution({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getExecutionQueryKey(options)
});

/**
 * Cancel execution
 *
 * Cancels a running execution
 */
export const cancelExecutionMutation = (options?: Partial<Options<CancelExecutionData>>): UseMutationOptions<CancelExecutionResponse, CancelExecutionError, Options<CancelExecutionData>> => {
    const mutationOptions: UseMutationOptions<CancelExecutionResponse, CancelExecutionError, Options<CancelExecutionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await cancelExecution({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listAlertsQueryKey = (options?: Options<ListAlertsData>) => createQueryKey('listAlerts', options);

/**
 * List alerts
 *
 * Returns a paginated list of alerts for the current tenant
 */
export const listAlertsOptions = (options?: Options<ListAlertsData>) => queryOptions<ListAlertsResponse, ListAlertsError, ListAlertsResponse, ReturnType<typeof listAlertsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listAlerts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAlertsQueryKey(options)
});

export const listAlertsInfiniteQueryKey = (options?: Options<ListAlertsData>): QueryKey<Options<ListAlertsData>> => createQueryKey('listAlerts', options, true);

/**
 * List alerts
 *
 * Returns a paginated list of alerts for the current tenant
 */
export const listAlertsInfiniteOptions = (options?: Options<ListAlertsData>) => infiniteQueryOptions<ListAlertsResponse, ListAlertsError, InfiniteData<ListAlertsResponse>, QueryKey<Options<ListAlertsData>>, number | Pick<QueryKey<Options<ListAlertsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListAlertsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAlerts({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAlertsInfiniteQueryKey(options)
});

/**
 * Create alert
 *
 * Creates a new alert
 */
export const createAlertMutation = (options?: Partial<Options<CreateAlertData>>): UseMutationOptions<CreateAlertResponse, CreateAlertError, Options<CreateAlertData>> => {
    const mutationOptions: UseMutationOptions<CreateAlertResponse, CreateAlertError, Options<CreateAlertData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAlert({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAlertQueryKey = (options: Options<GetAlertData>) => createQueryKey('getAlert', options);

/**
 * Get alert
 *
 * Returns a single alert by ID
 */
export const getAlertOptions = (options: Options<GetAlertData>) => queryOptions<GetAlertResponse, GetAlertError, GetAlertResponse, ReturnType<typeof getAlertQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAlert({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAlertQueryKey(options)
});

/**
 * Acknowledge alert
 *
 * Marks an alert as acknowledged
 */
export const acknowledgeAlertMutation = (options?: Partial<Options<AcknowledgeAlertData>>): UseMutationOptions<AcknowledgeAlertResponse, AcknowledgeAlertError, Options<AcknowledgeAlertData>> => {
    const mutationOptions: UseMutationOptions<AcknowledgeAlertResponse, AcknowledgeAlertError, Options<AcknowledgeAlertData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await acknowledgeAlert({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Resolve alert
 *
 * Marks an alert as resolved
 */
export const resolveAlertMutation = (options?: Partial<Options<ResolveAlertData>>): UseMutationOptions<ResolveAlertResponse, ResolveAlertError, Options<ResolveAlertData>> => {
    const mutationOptions: UseMutationOptions<ResolveAlertResponse, ResolveAlertError, Options<ResolveAlertData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await resolveAlert({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listAuditLogsQueryKey = (options?: Options<ListAuditLogsData>) => createQueryKey('listAuditLogs', options);

/**
 * List audit logs
 *
 * Returns a paginated list of audit logs for the current tenant
 */
export const listAuditLogsOptions = (options?: Options<ListAuditLogsData>) => queryOptions<ListAuditLogsResponse, ListAuditLogsError, ListAuditLogsResponse, ReturnType<typeof listAuditLogsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listAuditLogs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAuditLogsQueryKey(options)
});

export const listAuditLogsInfiniteQueryKey = (options?: Options<ListAuditLogsData>): QueryKey<Options<ListAuditLogsData>> => createQueryKey('listAuditLogs', options, true);

/**
 * List audit logs
 *
 * Returns a paginated list of audit logs for the current tenant
 */
export const listAuditLogsInfiniteOptions = (options?: Options<ListAuditLogsData>) => infiniteQueryOptions<ListAuditLogsResponse, ListAuditLogsError, InfiniteData<ListAuditLogsResponse>, QueryKey<Options<ListAuditLogsData>>, number | Pick<QueryKey<Options<ListAuditLogsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListAuditLogsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAuditLogs({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAuditLogsInfiniteQueryKey(options)
});

export const listAuditLogsByResourceQueryKey = (options: Options<ListAuditLogsByResourceData>) => createQueryKey('listAuditLogsByResource', options);

/**
 * List audit logs by resource
 *
 * Returns a paginated list of audit logs for a specific resource
 */
export const listAuditLogsByResourceOptions = (options: Options<ListAuditLogsByResourceData>) => queryOptions<ListAuditLogsByResourceResponse, ListAuditLogsByResourceError, ListAuditLogsByResourceResponse, ReturnType<typeof listAuditLogsByResourceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listAuditLogsByResource({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAuditLogsByResourceQueryKey(options)
});

export const listAuditLogsByResourceInfiniteQueryKey = (options: Options<ListAuditLogsByResourceData>): QueryKey<Options<ListAuditLogsByResourceData>> => createQueryKey('listAuditLogsByResource', options, true);

/**
 * List audit logs by resource
 *
 * Returns a paginated list of audit logs for a specific resource
 */
export const listAuditLogsByResourceInfiniteOptions = (options: Options<ListAuditLogsByResourceData>) => infiniteQueryOptions<ListAuditLogsByResourceResponse, ListAuditLogsByResourceError, InfiniteData<ListAuditLogsByResourceResponse>, QueryKey<Options<ListAuditLogsByResourceData>>, number | Pick<QueryKey<Options<ListAuditLogsByResourceData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListAuditLogsByResourceData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAuditLogsByResource({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAuditLogsByResourceInfiniteQueryKey(options)
});

export const listAuditLogsByUserQueryKey = (options: Options<ListAuditLogsByUserData>) => createQueryKey('listAuditLogsByUser', options);

/**
 * List audit logs by user
 *
 * Returns a paginated list of audit logs for a specific user
 */
export const listAuditLogsByUserOptions = (options: Options<ListAuditLogsByUserData>) => queryOptions<ListAuditLogsByUserResponse, ListAuditLogsByUserError, ListAuditLogsByUserResponse, ReturnType<typeof listAuditLogsByUserQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listAuditLogsByUser({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAuditLogsByUserQueryKey(options)
});

export const listAuditLogsByUserInfiniteQueryKey = (options: Options<ListAuditLogsByUserData>): QueryKey<Options<ListAuditLogsByUserData>> => createQueryKey('listAuditLogsByUser', options, true);

/**
 * List audit logs by user
 *
 * Returns a paginated list of audit logs for a specific user
 */
export const listAuditLogsByUserInfiniteOptions = (options: Options<ListAuditLogsByUserData>) => infiniteQueryOptions<ListAuditLogsByUserResponse, ListAuditLogsByUserError, InfiniteData<ListAuditLogsByUserResponse>, QueryKey<Options<ListAuditLogsByUserData>>, number | Pick<QueryKey<Options<ListAuditLogsByUserData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListAuditLogsByUserData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAuditLogsByUser({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAuditLogsByUserInfiniteQueryKey(options)
});
